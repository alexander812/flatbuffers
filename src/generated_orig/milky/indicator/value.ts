// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

import type { ActiveT } from '../../milky/indicator/active.js';
import { Active } from '../../milky/indicator/active.js';
import type { ColorT } from '../../milky/indicator/color.js';
import { Color } from '../../milky/indicator/color.js';
import type { OpacityT } from '../../milky/indicator/opacity.js';
import { Opacity } from '../../milky/indicator/opacity.js';
import type { PeriodsT } from '../../milky/indicator/periods.js';
import { Periods } from '../../milky/indicator/periods.js';
import type { StyleT } from '../../milky/indicator/style.js';
import { Style } from '../../milky/indicator/style.js';
import type { TypeT } from '../../milky/indicator/type.js';
import { Type } from '../../milky/indicator/type.js';
import { ValuesType, unionToValuesType, unionListToValuesType } from '../../milky/indicator/values-type.js';
import type { WidthT } from '../../milky/indicator/width.js';
import { Width } from '../../milky/indicator/width.js';

export class Value implements flatbuffers.IUnpackableObject<ValueT> {
  bb: flatbuffers.ByteBuffer | null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Value {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsValue(bb: flatbuffers.ByteBuffer, obj?: Value): Value {
    return (obj || new Value()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsValue(bb: flatbuffers.ByteBuffer, obj?: Value): Value {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Value()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  valueType(): ValuesType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : ValuesType.NONE;
  }

  value<T extends flatbuffers.Table>(obj: any): any | null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
  }

  static startValue(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addValueType(builder: flatbuffers.Builder, valueType: ValuesType) {
    builder.addFieldInt8(0, valueType, ValuesType.NONE);
  }

  static addValue(builder: flatbuffers.Builder, valueOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, valueOffset, 0);
  }

  static endValue(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createValue(
    builder: flatbuffers.Builder,
    valueType: ValuesType,
    valueOffset: flatbuffers.Offset,
  ): flatbuffers.Offset {
    Value.startValue(builder);
    Value.addValueType(builder, valueType);
    Value.addValue(builder, valueOffset);
    return Value.endValue(builder);
  }

  unpack(): ValueT {
    return new ValueT(
      this.valueType(),
      (() => {
        const temp = unionToValuesType(this.valueType(), this.value.bind(this));
        if (temp === null) {
          return null;
        }
        return temp.unpack();
      })(),
    );
  }

  unpackTo(_o: ValueT): void {
    _o.valueType = this.valueType();
    _o.value = (() => {
      const temp = unionToValuesType(this.valueType(), this.value.bind(this));
      if (temp === null) {
        return null;
      }
      return temp.unpack();
    })();
  }
}

export class ValueT implements flatbuffers.IGeneratedObject {
  constructor(
    public valueType: ValuesType = ValuesType.NONE,
    public value: ActiveT | ColorT | OpacityT | PeriodsT | StyleT | TypeT | WidthT | null = null,
  ) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const value = builder.createObjectOffset(this.value);

    return Value.createValue(builder, this.valueType, value);
  }
}

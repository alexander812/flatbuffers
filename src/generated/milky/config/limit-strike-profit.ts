// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

export class LimitStrikeProfit implements flatbuffers.IUnpackableObject<LimitStrikeProfitT> {
  bb: flatbuffers.ByteBuffer | null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LimitStrikeProfit {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLimitStrikeProfit(bb: flatbuffers.ByteBuffer, obj?: LimitStrikeProfit): LimitStrikeProfit {
    return (obj || new LimitStrikeProfit()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLimitStrikeProfit(
    bb: flatbuffers.ByteBuffer,
    obj?: LimitStrikeProfit,
  ): LimitStrikeProfit {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LimitStrikeProfit()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  up(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  down(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startLimitStrikeProfit(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addUp(builder: flatbuffers.Builder, up: number) {
    builder.addFieldInt32(0, up, 0);
  }

  static addDown(builder: flatbuffers.Builder, down: number) {
    builder.addFieldInt32(1, down, 0);
  }

  static endLimitStrikeProfit(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLimitStrikeProfit(builder: flatbuffers.Builder, up: number, down: number): flatbuffers.Offset {
    LimitStrikeProfit.startLimitStrikeProfit(builder);
    LimitStrikeProfit.addUp(builder, up);
    LimitStrikeProfit.addDown(builder, down);
    return LimitStrikeProfit.endLimitStrikeProfit(builder);
  }

  unpack(): LimitStrikeProfitT {
    return new LimitStrikeProfitT(this.up(), this.down());
  }

  unpackTo(_o: LimitStrikeProfitT): void {
    _o.up = this.up();
    _o.down = this.down();
  }
}

export class LimitStrikeProfitT implements flatbuffers.IGeneratedObject {
  constructor(public up: number = 0, public down: number = 0) {}

  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LimitStrikeProfit.createLimitStrikeProfit(builder, this.up, this.down);
  }
}
